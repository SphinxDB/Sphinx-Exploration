[![DECO](https://www.deco.works/static/images/logo.png)](https://www.deco.works)

## What is DECO briefly?

DECO is a privacy-preserving oracle protocol. Using cryptographic techniques, it lets users prove facts about their web (TLS) sessions to oracles while hiding privacy-sensitive data.[1]

## Who created DECO?

DECO is a novel privacy-preserving oracle protocol, created by students and faculty at IC3. Full [team](https://www.deco.works/team) can be found here.

## Who are using DECO?

[Chainlink Acquires DECO from Cornell University](https://www.prnewswire.com/news-releases/chainlink-acquires-deco-from-cornell-university-301120614.html)

## How does it work?

This part is briefly explains ChainLink's DECO Research Series since they are working with DECO and some of the DECO developers and researchers committed to the series it is a reliable resource.

DECO uses ZKPs to ensure privacy and verify a part of a data. Web server's identity is verified for every session with TLS by client. It uses VOLE-based ZKP to benefit from higher speed as “commit-and-prove” form of ZKP which makes TLS and DECO interactive protocols

DECO uses 3 party handshake to prove the incoming data;
![Basic DECO diagram](https://blog.chain.link/wp-content/uploads/2023/03/deco-in-action-2048x1152.png)
Simply the flow in High-level looks like;

1. The prover commits to the inputs of the circuit.
2. Together the prover and the verifier compute the commitments to the outputs of the gates going through them in topological order.
3. The prover opens the commitments to the outputs of the circuit.

And this process is conducted in 4 steps;

1. Proving the authenticity of data
2. Parsing the response
3. Hiding the length of the sensitive data
4. Proofs over multiple responses

#### Proving the authenticity of data

As mentioned above we will have 3 actors web server, prover, and verifier. In this report the technics of generating the ZKP will not be explained widely. Only there will be some short explanations of what is going on in the workflow. In the authentication part verifier will have the role of a proxy without knowing the prover's and web servers's `K` value generated by a key exchange protocol e.g.Diffie-Hellman. It brings some vulnerabilities. DECO asks the prover to show a key binding proof to prove the commitment `[K]` to the session key is generated correctly.

After key agreement verifier holds the commitment `[K]`, gets encrypted response `C`, and prover gets the response `R`. Prover and verifier computes commitment `[R]` to the response `R` with the ZKP protocol (This part is not clearly explained on the research since `R=decrypt(K, C)` and verifier has `[K]` and `C`). In the end prover and verifier hold a commitment `[R]` and verifier convinced the data is authenticated.

The diagram below shows the process explained above;
![DECO's Proving the authenticity of data diagram](https://blog.chain.link/wp-content/uploads/2023/04/deco-diagram-provenance-2048x1153.png)

#### Parsing the response

In the part before at the end verifier held commitment [R], `R` is a bytes array or a string. DECO enables to give information to verifier without leaking the sensitive part of information. Prover can claim they have more than $1m without showing their balance. Lets sat the JSON below is `R`.

```JSON
{
    "balance": 2000000,
    "account_id": 156461324651,
}
```

In this part it will be seen that how the balance data is parsed and it's correctness can be verified.

With ZKP's the computation takes too long to compute for parsing a JSON so in practice JSON rarely includes sensitive information. So prover can help parsing JSON with selective opening. Let's see how it works in a very high level perspective. A prover wants to prove they have no negative balances in any of their accounts. The `R` is;

```JSON
{
    "accounts":[
        {
            "balance": 12345,
            "account_id": 156461324651,
        },
        {
            "balance": 1000000,
            "account_id": 213612867132,
        },
        {
            "balance": 2000000,
            "account_id": 371823713701,
        }
    ]
}
```

Honest prover sends redacted JSON;

```JSON
{
    "accounts":[
        {
            "balance": "",
            "account_id": "",
        },
        {
            "balance": "",
            "account_id": "",
        },
        {
            "balance": "",
            "account_id": "",
        }
    ]
}
```

and commits the array of scalars Z.

```JSON
[
    "12345",
    "156461324651",
    "1000000",
    "213612867132",
    "2000000",
    "371823713701"
]
```

The prover and the verifier both locally compute the array of indices as `J = [0, 2, 4]` Then they evaluate through ZKP the function `min(Z[J]) > 0` and since all the values `["12345", "1000000", "2000000"]` are higher than zero it is verified that they have no negative balance on their account.

There should be some soundness checks afterwards since the verifier relies on data that prover provided and it may not be true there are in total 4 checks.

##### Check 0:

Verifier checks `R'` is indeed a valid JSON. Verifier relies on correct JSON Parser

##### Check 1:

Next, the verifier checks if the committed values in the array indeed come from the response. For this, both parties locally compute an array of split strings `P` by splitting the redacted JSON `R'` at the location of the scalars and removing the scalars themselves.

They now use the commitments `[R]` and `[Z]` to evaluate the reconstruction statement in ZK with bitwise concatenation. If the prover alters any value in `Z`, this equality check fails.

##### Check 2:

Verifier checks if redacted `R'` and `Z` is fully sent without any changes because not honest prover can delete one or more records so that balance is lower than zero and can still pass the check 1.

##### Check 3:

This final check checks if all the scalars `Z` are sent

Check how it is done deeply by reference [4] where there are more detailed representation can be found.

#### Hiding the length of the sensitive data

The prover may not wan't to leak information about the values' lengths inside the JSON such as digits of an account's balance. Most of the ZKP protocols in general doesn't hide the length data. Prover can pad the JSON scalars using DECO.

It may not be directly known that a value is (lets say) a balance, but there can be some assumptions such as, if a website lets prover pick a username with at least 10 letters or more than 9 digits may not be shown these 10+ letters name can be assumed as a username and 8 digits output can be assumed as a balance and verifier can assume who that information belongs to. So verifier may make some precise assumptions on those that is why hiding length of the outputs is crucial.

![DECO Private and Public Data Exchange Flow](https://blog.chain.link/wp-content/uploads/2023/06/DECO-Research-Series-4-Diagrams-V2_1-2048x624.png)

In the table above it is shown that arrows which has locks on them are private values and the others are public values.

What is padding prover was sending the scalars `Z` int the previous examples but lengths can be found to solve that prover can make a `Y` and `G` arrays. `Y = Z'` is for the padded data and `G` is for actual length of the data. And prover can send only the related field's length let's say prover wants to reveal `i` th data's length should send the `G[i]` and `Y[i]`. Concatenation of the `G` and `Y` should look like the array below. 0s are used for padding in the example but some arbitrary character can be used.

```JavaScript
[
    ( "\"Alice Liddell\"000000000", 15 ),
    ( "\"012-345-6789\"0000000000", 14 ),
    ( "\"05-16-2023\"000000", 12 ),
    ( "12345000000000000000000000000000", 5 ),
    ( "1564613246510000", 12 ),
    ( "1000000000000000000000000000000", 7 ),
    ( "2136128671320000", 12 ),
    ( "20000000000000000000000000000000", 7 ),
    ( "3718237137010000", 12 )
]
```

DECO moves all the paddings to the most right hand side of the data with a length-hiding reconstruction circuit.

> `"{\n \"name\" : \"Alice Liddell\",\n \"ssn\" : \"012-345-6789\",\n \"date_generated\": \"05-16-2023\",\n \"accounts\": [\n {\n \"balance\": 12345,\n \"account_id\": 156461324651 \n },\n {\n \"balance\": 1000000,\n \"account_id\": 213612867132 \n },\n {\n \"balance\": 2000000,\n \"account_id\": 371823713701 \n }\n ]\n}000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"`

Since the right-hand side of the equality check is longer than the left due to the padding, the reconstructed string on the right is truncated up to the length of `R`. Both prover and verifier know the length of the response `R` since it corresponds to the length of the TLS ciphertext `C`.

This padding can lead to some security issues such as prover can have 2.000.000 dollars of balance but they can send the padding argument as 8 and this leads to a wrong argument as the prover has 20.000.000 dollars in their account since the padding value is 0 it could be valid. Or they can input 6 which could lead to the same situation visa versa. It is avoided by checking the response `R` and sent `Y` and `G`, if prover enters less, or higher number than the original value's length the outputs doesn't match. The example cases which reconstruction statement will evaluate to `false` can be seen below;

`("12345000000000000000000000000000",2)` (the actual length is 5) and output is;

> `"{\n \"name\" : \"Alice Liddell\",\n \"ssn\" : \"012-345-6789\",\n \"date_generated\": \"05-16-2023\",\n \"accounts\": [\n {\n \"balance\": 12,\n \"account_id\": 156461324651 \n },\n {\n \"balance\": 1000000,\n \"account_id\": 213612867132 \n },\n {\n \"balance\": 2000000,\n \"account_id\": 371823713701 \n }\n ]\n}3450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"`

`("12345000000000000000000000000000",10)` (the actual length is 5) and output is;

> `"{\n \"name\" : \"Alice Liddell\",\n \"ssn\" : \"012-345-6789\",\n \"date_generated\": \"05-16-2023\",\n \"accounts\": [\n {\n \"balance\": 1234500000,\n \"account_id\": 156461324651 \n },\n {\n \"balance\": 1000000,\n \"account_id\": 213612867132 \n },\n {\n \"balance\": 2000000,\n \"account_id\": 371823713701 \n }\n ]\n}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"`

Length-Hiding Concatenation Circuit should be checked from the last blog since it has too much ZKP circuit operation and calculation. It is not reliable to include under this topic.

If you need more resource the links to the blog series are listed under [references](#references)[2][3][4][5]

## Why should we use DECO and how much is it related with Sphinx?

For Sphinx it is a need to trustlessly fetch web2 data onto web3 so Sphinx is a good use case for DECO. Although DECO can be a protocol Sphinx should be inspired of, it is not the solution that Sphinx should provide since it is aiming to become a network which means trustlessness will be enhanced by the other nodes.

## Advantages of using DECO

- Fast
- Trustless
- Parsing part can be considered it will spend low computation and can be implement such solution in Sphinx.
- Interface can be implemented for developers to generate proofs from different sources.

## Disadvantages of using DECO

- Not open source yet.
- Gets patented by ChainLink, in our case that may not be a problem or it maybe, there should be a research conducted to make sure it is legal for our use.
- Private key generation on-chain can be a problem, but there can be a solution for that like randao on Ethereum.(Proposer can derive a pk with other nodes pks and proves the proof and other nodes can attest to the proof)

## References

1. [DECO.works](https://www.deco.works/)
2. [DECO Research Series #1: Introduction | Chainlink Blog](https://blog.chain.link/deco-introduction/)
3. [DECO Research Series #2: Provenance and Authenticity | Chainlink Blog](https://blog.chain.link/deco-provenance-and-authenticity/)
4. [DECO Research Series #3: Parsing the Response | Chainlink Blog](https://blog.chain.link/deco-parsing-the-response/)
5. [DECO Research Series #4: Hiding Secret Lengths | Chainlink Blog](https://blog.chain.link/hiding-secret-lengths/)
